/**
 * HD 钱包
 * 
 * 某个用户持有的比特币，实际上是其控制的一组UTXO，而这些UTXO可能是相同的地址（对应相同的私钥），也可能是不同的地址（对应不同的私钥）。
 * 
 * 能不能只用一个私钥管理成千上万个地址？实际上是可以的。
 * 虽然椭圆曲线算法决定了一个私钥只能对应一个公钥，但是，可以通过某种确定性算法，
 * 先确定一个私钥k1，然后计算出k2、k3、k4……等其他私钥，就相当于只需要管理一个私钥，剩下的私钥可以按需计算出来。
 * 这种根据某种确定性算法，只需要管理一个根私钥，即可实时计算所有“子私钥”的管理方式，称为HD钱包。
 * HD是Hierarchical Deterministic的缩写，意思是分层确定性。先确定根私钥root，然后根据索引计算每一层的子私钥
 * 
 * HD钱包采用的计算子私钥的算法一个扩展的512位私钥，记作xprv，
 * 它通过SHA-512算法配合ECC计算出子扩展私钥，仍然是512位。通过扩展私钥可计算出用于签名的私钥以及公钥。
 * 扩展私钥总是能计算出扩展公钥，记作xpub
 * 因为xpub只包含公钥，不包含私钥，因此，可以安全地把xpub交给第三方（例如，一个观察钱包），它可以根据xpub计算子层级的所有地址，然后在比特币的链上监控这些地址的余额，但因为没有私钥，所以只能看，不能花。
 * 
 * 因此，HD钱包通过分层确定性算法，实现了以下功能：
 * 1、  只要确定了扩展私钥xprv，即可根据索引计算下一层的任何扩展私钥；
 * 2、  只要确定了扩展公钥xpub，即可根据索引计算下一层的任何扩展公钥；
 * 3、  用户只需保存顶层的一个扩展私钥，即可计算出任意一层的任意索引的扩展私钥。
 * 从理论上说，扩展私钥的层数是没有限制的，每一层的数量被限制在0～2^32，原因是扩展私钥中只有4字节作为索引，因此索引范围是0～2^32。
 * 通常把根扩展私钥记作m，子扩展私钥按层级记作m/x/y/z等：例如，m/0/2表示从m扩展到m/0（索引为0）再扩展到m/0/2（索引为2）。
 * 
 * 但是HD钱包的扩展私钥算法有个潜在的安全性问题，就是如果某个层级的xprv泄露了，可反向推导出上层的xprv，继而推导出整个HD扩展私钥体系。
 * 为了避免这个问题，HD钱包还有一种硬化的衍生计算方式（Hardened Derivation），
 * 它通过算法“切断”了母扩展私钥和子扩展私钥的反向推导。HD规范把索引0～2^31作为普通衍生索引，
 * 而索引2^31～2^32作为硬化衍生索引，硬化衍生索引通常记作0'、1'、2'……，即索引0'=2^31，1'=2^31+1，2'=2^31+2，以此类推。
 * 例如：m/44'/0表示的子扩展私钥，它的第一层衍生索引44'是硬化衍生，实际索引是2^31+44=2147483692。从m/44'/0无法反向推导出m/44'。
 * 
 * 比特币的BIP-32规范详细定义了HD算法原理和各种推导规则，可阅读此文档以便实现HD钱包。
 */

const bitcoin = require('bitcoinjs-lib');
let 
    xprv = 'xprv9s21ZrQH143K4EKMS3q1vbJo564QAbs98BfXQME6nk8UCrnXnv8vWg9qmtup3kTug96p5E3AvarBhPMScQDqMhEEm41rpYEdXBL8qzVZtwz',
    root = bitcoin.HDNode.fromBase58(xprv);
// m/0
var m_0 = root.derive(0);
console.log('xprv m/0:'+m_0.toBase58());
console.log('xprv m/0:'+m_0.neutered().toBase58());
console.log(' prv m/0:'+m_0.keyPair.toWIF());
console.log(' pub m/0:'+m_0.keyPair.getAddress());
// m/1
var m_1 = root.derive(0);
console.log('xprv m/1:'+m_1.toBase58());
console.log('xprv m/1:'+m_1.neutered().toBase58());
console.log(' prv m/1:'+m_1.keyPair.toWIF());
console.log(' pub m/1:'+m_1.keyPair.getAddress());